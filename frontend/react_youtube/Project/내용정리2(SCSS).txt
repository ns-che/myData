웹폰트(Web Fonts): 사용자 컴퓨터에 폰트 없어도 다운받고 바로 사용 가능 => 특정 폰트 사용하려면 해당 기술 필요
TTF, OTF: 파일크기 큼
WOFF: 웹 페이지 최적
EOT: 익스플로러

1) _fonts.scss
@font-face {
    font-family: "[폰트종류]";
    font-weight: 100;
    font-style: normal;
    src: url("../../fonts/[폰트이름].woff") format("woff");
    font-display: swap;
}

2) _vars.scss
변수설정, 변수의 초기값설정(ex) 폰트 -> @media태그로 화면변화에 따른 초기값도 설정)
--변수명: 값(ex) "abc", #fff);

3) _reset.scss
초기 화면 + 리셋 화면 설정
브라우저가 달라도 일관된 스타일이 나오도록 하기 위함
=> HTML 요소와 레이아웃(before,after,blind 등) 초기속성값 설정

@import 'setting/fonts'; 폰트
@import 'setting/vars'; 변수
@import 'setting/reset';
@import 'setting/mixin';
@import 'setting/common'; 

변수를 뜻하는 vars가 앞에 위치하므로 reset, mixin, common은 변수 사용이 자유롭다

4) _common.scss
사이트에서 모든 화면에 공통될 스타일
============================================================
페이지 만들기
기존 웹 : 페이지 바뀔때마다 전체 다시 렌더링
가상 DOM 활용: 필요한 부분만 다시 렌더링 => 속도 빠름

DOM: 구조적(HTML, XML 등)인 요소들의 트리구조 => 실제 메모리에 존재
가상DOM: 실제 DOM의 복제 => 변경사항 비교후 최소한의 DOM 조작만 수행(업데이트 효율적)

왜 react-router-dom을 쓰느냐?

URL과 상태를 연결해줌 (주소창 관리)

브라우저 주소창이 /about, /users/3 같은 식으로 바뀌면,
새로고침해도 그대로 그 페이지가 열립니다.

직접 구현하려면 window.history.pushState, popstate 이벤트를 다뤄야 해서 귀찮고 복잡합니다.

👉 react-router-dom이 이걸 알아서 해줍니다.

복잡한 라우팅 관리

예: /users/:id, /admin/*, 중첩 라우트 같은 구조.

직접 구현하려면 문자열 파싱, 조건 분기, URL 매칭을 전부 손수 처리해야 합니다.

👉 react-router-dom의 <Routes>, <Route>가 자동으로 매칭해줍니다.

페이지 간 이동 애니메이션, 보호된 라우트(로그인 필요 페이지) 등 확장성

“로그인 안 된 사용자는 /login으로 리다이렉트” 같은 기능이 매우 쉽게 가능.

직접 짜면 훨씬 복잡합니다.

SPA의 표준적인 패턴

대부분의 React 프로젝트가 react-router-dom을 사용하기 때문에, 협업이나 유지보수 시 “암묵적 규칙”처럼 되어 있습니다.

즉, 남이 만든 React 코드 이해할 때도 도움이 됩니다.